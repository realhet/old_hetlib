unit UVector;

interface
uses Windows, SysUtils;

{ define indexer(what,num) what}
{ define concat2(what,separ) indexer(what,0)separ##indexer(what,1)}
{ define concat3(what,separ) concat2(what,separ)separ##indexer(what,2)}
{ define concat4(what,separ) concat3(what,separ)separ##indexer(what,3)}

{ define _HUnary(n,t,name) class operator name(a:TV##n##t):TV##n##t;inline}
{ define _HCompare(n,t,name) class operator name(a,b:TV##n##t):boolean;inline}
{ define _HBinary(n,t,name) class operator name(a,b:TV##n##t):TV##n##t;inline}
{ define _HScalar(n,t,typ,name) class operator name(a:TV##n##t;b:typ):TV##n##t;inline}
{ define _HImplicitFromInt(n,t) class operator Implicit(a:TV##n##i):TV##n##t;inline}
{ define _HTrunc(n,t,name) class operator name(a:TV##n##t):TV##n##i;inline}

{ define _BUnary(n,t,name,op) class operator TV##n##t.name(a:TV##n##t):TV##n##t;begin concat##n(result.v[num]:= op a.V[num],;);end}
{ define _BBinary(n,t,name,op) class operator TV##n##t.name(a,b:TV##n##t):TV##n##t;begin concat##n(result.v[num]:=a.V[num] op b.V[num],;);end}
{ define _BScalar(n,t,typ,name,op) class operator TV##n##t.name(a:TV##n##t;b:typ):TV##n##t;begin concat##n(result.v[num]:=a.V[num] op b,;);end}
{ define _BCompare(n,t,name,op,and) class operator TV##n##t.name(a,b:TV##n##t):boolean;begin result:=concat##n((a.V[num] op b.V[num]),and );end}
{ define _BImplicitFromInt(n,t) class operator TV##n##t.Implicit(a:TV##n##i):TV##n##t;begin concat##n(result.v[num]:=a.v[num],;);end}
{ define _BTrunc(n,t,name) class operator TV##n##t.name(a:TV##n##t):TV##n##i;begin concat##n(result.v[num]:=name(a.v[num]),;);end}

{ define _HSimple(n,t,typ)
  _HUnary(n,t,Negative);
  _HCompare(n,t,Equal);
  _HCompare(n,t,NotEqual);
  _HCompare(n,t,GreaterThan);
  _HCompare(n,t,GreaterThanOrEqual);
  _HCompare(n,t,LessThan);
  _HCompare(n,t,LessThanOrEqual);
  _HBinary(n,t,Add);
  _HBinary(n,t,Subtract);
  _HBinary(n,t,Multiply);
  _HScalar(n,t,typ,Multiply)}

{ define _HInteger(n,t,typ)
  _HSimple(n,t,typ);
  _HBinary(n,t,IntDivide);    _HScalar(n,t,typ,IntDivide);
  _HBinary(n,t,Modulus);      _HScalar(n,t,typ,Modulus);
  _HBinary(n,t,LeftShift);    _HScalar(n,t,typ,LeftShift);
  _HBinary(n,t,RightShift);   _HScalar(n,t,typ,RightShift);
  _HBinary(n,t,BitwiseAnd);   _HScalar(n,t,typ,BitwiseAnd);
  _HBinary(n,t,BitwiseOr);    _HScalar(n,t,typ,BitwiseOr);
  _HBinary(n,t,BitwiseXor);   _HScalar(n,t,typ,BitwiseXor)}

{ define _HFloat(n,t,typ)
  _HImplicitFromInt(n,t);
  _HSimple(n,t,typ);
  _HBinary(n,t,Divide);       _HScalar(n,t,typ,Divide);
  _HTrunc(n,t,Trunc);
  _HTrunc(n,t,Round)}

{ define _BSimple(n,t,typ)
  _BUnary(n,t,Negative,-);
  _BCompare(n,t,Equal,=,and);
  _BCompare(n,t,NotEqual,<>,or);
  _BCompare(n,t,GreaterThan,>,and);
  _BCompare(n,t,GreaterThanOrEqual,>=,and);
  _BCompare(n,t,LessThan,<,and);
  _BCompare(n,t,LessThanOrEqual,<=,and);
  _BBinary(n,t,Add,+);
  _BBinary(n,t,Subtract,-);
  _BBinary(n,t,Multiply,*);
  _BScalar(n,t,typ,Multiply,*)}

{ define _BInteger(n,t,typ)
  _BSimple(n,t,typ);
  _BBinary(n,t,IntDivide,div);    _BScalar(n,t,typ,IntDivide,div);
  _BBinary(n,t,Modulus,mod);      _BScalar(n,t,typ,Modulus,mod);
  _BBinary(n,t,LeftShift,shl);    _BScalar(n,t,typ,LeftShift,shl);
  _BBinary(n,t,RightShift,shr);   _BScalar(n,t,typ,RightShift,shr);
  _BBinary(n,t,BitwiseAnd,and);   _BScalar(n,t,typ,BitwiseAnd,and);
  _BBinary(n,t,BitwiseOr,or);     _BScalar(n,t,typ,BitwiseOr,or);
  _BBinary(n,t,BitwiseXor,xor);   _BScalar(n,t,typ,BitwiseXor,xor)}

{ define _BFloat(n,t,typ)
  _BImplicitFromInt(n,t);
  _BSimple(n,t,typ);
  _BBinary(n,t,Divide,/);       _BScalar(n,t,typ,Divide,/);
  _BTrunc(n,t,Trunc);
  _BTrunc(n,t,Round)}

type
{ define intDef(n,t,typ) TV##n##t=packed record V:array[0..n-1]of typ;_HInteger(n,t,typ);end; TV##n##t##Array=array of TV##n##t##}
  TV2i=packed record x,y:integer;class operator Negative(a:TV2i):TV2i;inline;class operator Equal(a,b:TV2i):boolean;inline;class operator NotEqual(a,b:TV2i):boolean;inline;class operator GreaterThan(a,b:TV2i):boolean;inline;class operator GreaterThanOrEqual(a,b:TV2i):boolean;inline;class operator LessThan(a,b:TV2i):boolean;inline;class operator LessThanOrEqual(a,b:TV2i):boolean;inline;class operator Add(a,b:TV2i):TV2i;inline;class operator Subtract(a,b:TV2i):TV2i;inline;class operator Multiply(a,b:TV2i):TV2i;inline;class operator Multiply(a:TV2i;b:integer):TV2i;inline;class operator IntDivide(a,b:TV2i):TV2i;inline;class operator IntDivide(a:TV2i;b:integer):TV2i;inline;class operator Modulus(a,b:TV2i):TV2i;inline;class operator Modulus(a:TV2i;b:integer):TV2i;inline;class operator LeftShift(a,b:TV2i):TV2i;inline;class operator LeftShift(a:TV2i;b:integer):TV2i;inline;class operator RightShift(a,b:TV2i):TV2i;inline;class operator RightShift(a:TV2i;b:integer):TV2i;inline;
class operator BitwiseAnd(a,b:TV2i):TV2i;inline;class operator BitwiseAnd(a:TV2i;b:integer):TV2i;inline;class operator BitwiseOr(a,b:TV2i):TV2i;inline;class operator BitwiseOr(a:TV2i;b:integer):TV2i;inline;class operator BitwiseXor(a,b:TV2i):TV2i;inline;class operator BitwiseXor(a:TV2i;b:integer):TV2i;inline;end;TV2iArray=array of TV2i;
  TV3i=packed record x,y,z:integer;function GetCoord(i:integer):integer;procedure SetCoord(i:integer;a:integer);property Coord[i:integer]:integer read GetCoord write SetCoord; class operator Negative(a:TV3i):TV3i;inline;class operator Equal(a,b:TV3i):boolean;inline;class operator NotEqual(a,b:TV3i):boolean;inline;class operator GreaterThan(a,b:TV3i):boolean;inline;class operator GreaterThanOrEqual(a,b:TV3i):boolean;inline;class operator LessThan(a,b:TV3i):boolean;inline;class operator LessThanOrEqual(a,b:TV3i):boolean;inline;class operator Add(a,b:TV3i):TV3i;inline;class operator Subtract(a,b:TV3i):TV3i;inline;class operator Multiply(a,b:TV3i):TV3i;inline;class operator Multiply(a:TV3i;b:integer):TV3i;inline;class operator IntDivide(a,b:TV3i):TV3i;inline;class operator IntDivide(a:TV3i;b:integer):TV3i;inline;class operator Modulus(a,b:TV3i):TV3i;inline;class operator Modulus(a:TV3i;b:integer):TV3i;inline;class operator LeftShift(a,b:TV3i):TV3i;inline;class operator LeftShift(a:TV3i;b:integer):TV3i;inline;class operator RightShift(a,b:TV3i):TV3i;inline;class operator RightShift(a:TV3i;b:integer):TV3i;inline;
class operator BitwiseAnd(a,b:TV3i):TV3i;inline;class operator BitwiseAnd(a:TV3i;b:integer):TV3i;inline;class operator BitwiseOr(a,b:TV3i):TV3i;inline;class operator BitwiseOr(a:TV3i;b:integer):TV3i;inline;class operator BitwiseXor(a,b:TV3i):TV3i;inline;class operator BitwiseXor(a:TV3i;b:integer):TV3i;inline;end;TV3iArray=array of TV3i;
  TV4i=packed record x,y,z,w:integer;class operator Negative(a:TV4i):TV4i;inline;class operator Equal(a,b:TV4i):boolean;inline;class operator NotEqual(a,b:TV4i):boolean;inline;class operator GreaterThan(a,b:TV4i):boolean;inline;class operator GreaterThanOrEqual(a,b:TV4i):boolean;inline;class operator LessThan(a,b:TV4i):boolean;inline;class operator LessThanOrEqual(a,b:TV4i):boolean;inline;class operator Add(a,b:TV4i):TV4i;inline;class operator Subtract(a,b:TV4i):TV4i;inline;class operator Multiply(a,b:TV4i):TV4i;inline;class operator Multiply(a:TV4i;b:integer):TV4i;inline;class operator IntDivide(a,b:TV4i):TV4i;inline;class operator IntDivide(a:TV4i;b:integer):TV4i;inline;class operator Modulus(a,b:TV4i):TV4i;inline;class operator Modulus(a:TV4i;b:integer):TV4i;inline;class operator LeftShift(a,b:TV4i):TV4i;inline;class operator LeftShift(a:TV4i;b:integer):TV4i;inline;class operator RightShift(a,b:TV4i):TV4i;inline;class operator RightShift(a:TV4i;b:integer):TV4i;inline;
class operator BitwiseAnd(a,b:TV4i):TV4i;inline;class operator BitwiseAnd(a:TV4i;b:integer):TV4i;inline;class operator BitwiseOr(a,b:TV4i):TV4i;inline;class operator BitwiseOr(a:TV4i;b:integer):TV4i;inline;class operator BitwiseXor(a,b:TV4i):TV4i;inline;class operator BitwiseXor(a:TV4i;b:integer):TV4i;inline;end;TV4iArray=array of TV4i;

{ define floatDef(n,t,typ) TV##n##t=packed record V:array[0..n-1]of typ;_HFloat(n,t,typ);end; TV##n##t##Array=array of TV##n##t##}
  TV2f=packed record x,y:single;function GetCoord(i:integer):single;procedure SetCoord(i:integer;a:single);property Coord[i:integer]:single read GetCoord write SetCoord; class operator Implicit(a:TV2i):TV2f;inline;class operator Negative(a:TV2f):TV2f;inline;class operator Equal(a,b:TV2f):boolean;inline;class operator NotEqual(a,b:TV2f):boolean;inline;class operator GreaterThan(a,b:TV2f):boolean;inline;class operator GreaterThanOrEqual(a,b:TV2f):boolean;inline;class operator LessThan(a,b:TV2f):boolean;inline;class operator LessThanOrEqual(a,b:TV2f):boolean;inline;class operator Add(a,b:TV2f):TV2f;inline;class operator Subtract(a,b:TV2f):TV2f;inline;class operator Multiply(a,b:TV2f):TV2f;inline;class operator Multiply(a:TV2f;b:single):TV2f;inline;class operator Divide(a,b:TV2f):TV2f;inline;class operator Divide(a:TV2f;b:single):TV2f;inline;class operator Trunc(a:TV2f):TV2i;inline;class operator Round(a:TV2f):TV2i;inline;end;TV2fArray=array of TV2f;
  TV3f=packed record x,y,z:single;function GetCoord(i:integer):single;procedure SetCoord(i:integer;a:single);property Coord[i:integer]:single read GetCoord write SetCoord; class operator Implicit(a:TV3i):TV3f;inline;class operator Negative(a:TV3f):TV3f;inline;class operator Equal(a,b:TV3f):boolean;inline;class operator NotEqual(a,b:TV3f):boolean;inline;class operator GreaterThan(a,b:TV3f):boolean;inline;class operator GreaterThanOrEqual(a,b:TV3f):boolean;inline;class operator LessThan(a,b:TV3f):boolean;inline;class operator LessThanOrEqual(a,b:TV3f):boolean;inline;class operator Add(a,b:TV3f):TV3f;inline;class operator Subtract(a,b:TV3f):TV3f;inline;class operator Multiply(a,b:TV3f):TV3f;inline;class operator Multiply(a:TV3f;b:single):TV3f;inline;class operator Divide(a,b:TV3f):TV3f;inline;class operator Divide(a:TV3f;b:single):TV3f;inline;class operator Trunc(a:TV3f):TV3i;inline;class operator Round(a:TV3f):TV3i;inline;end;TV3fArray=array of TV3f;
  TV4f=packed record x,y,z,w:single;function GetCoord(i:integer):single;procedure SetCoord(i:integer;a:single);property Coord[i:integer]:single read GetCoord write SetCoord; class operator Implicit(a:TV4i):TV4f;inline;class operator Negative(a:TV4f):TV4f;inline;class operator Equal(a,b:TV4f):boolean;inline;class operator NotEqual(a,b:TV4f):boolean;inline;class operator GreaterThan(a,b:TV4f):boolean;inline;class operator GreaterThanOrEqual(a,b:TV4f):boolean;inline;class operator LessThan(a,b:TV4f):boolean;inline;class operator LessThanOrEqual(a,b:TV4f):boolean;inline;class operator Add(a,b:TV4f):TV4f;inline;class operator Subtract(a,b:TV4f):TV4f;inline;class operator Multiply(a,b:TV4f):TV4f;inline;class operator Multiply(a:TV4f;b:single):TV4f;inline;class operator Divide(a,b:TV4f):TV4f;inline;class operator Divide(a:TV4f;b:single):TV4f;inline;class operator Trunc(a:TV4f):TV4i;inline;class operator Round(a:TV4f):TV4i;inline;end;TV4fArray=array of TV4f;

  TV2d=packed record x,y:double;class operator Implicit(a:TV2i):TV2d;inline;class operator Negative(a:TV2d):TV2d;inline;class operator Equal(a,b:TV2d):boolean;inline;class operator NotEqual(a,b:TV2d):boolean;inline;class operator GreaterThan(a,b:TV2d):boolean;inline;class operator GreaterThanOrEqual(a,b:TV2d):boolean;inline;class operator LessThan(a,b:TV2d):boolean;inline;class operator LessThanOrEqual(a,b:TV2d):boolean;inline;class operator Add(a,b:TV2d):TV2d;inline;class operator Subtract(a,b:TV2d):TV2d;inline;class operator Multiply(a,b:TV2d):TV2d;inline;class operator Multiply(a:TV2d;b:double):TV2d;inline;class operator Divide(a,b:TV2d):TV2d;inline;class operator Divide(a:TV2d;b:double):TV2d;inline;class operator Trunc(a:TV2d):TV2i;inline;class operator Round(a:TV2d):TV2i;inline;end;TV2dArray=array of TV2d;
  TV3d=packed record x,y,z:double;class operator Implicit(a:TV3i):TV3d;inline;class operator Negative(a:TV3d):TV3d;inline;class operator Equal(a,b:TV3d):boolean;inline;class operator NotEqual(a,b:TV3d):boolean;inline;class operator GreaterThan(a,b:TV3d):boolean;inline;class operator GreaterThanOrEqual(a,b:TV3d):boolean;inline;class operator LessThan(a,b:TV3d):boolean;inline;class operator LessThanOrEqual(a,b:TV3d):boolean;inline;class operator Add(a,b:TV3d):TV3d;inline;class operator Subtract(a,b:TV3d):TV3d;inline;class operator Multiply(a,b:TV3d):TV3d;inline;class operator Multiply(a:TV3d;b:double):TV3d;inline;class operator Divide(a,b:TV3d):TV3d;inline;class operator Divide(a:TV3d;b:double):TV3d;inline;class operator Trunc(a:TV3d):TV3i;inline;class operator Round(a:TV3d):TV3i;inline;end;TV3dArray=array of TV3d;
  TV4d=packed record x,y,z,w:double;class operator Implicit(a:TV4i):TV4d;inline;class operator Negative(a:TV4d):TV4d;inline;class operator Equal(a,b:TV4d):boolean;inline;class operator NotEqual(a,b:TV4d):boolean;inline;class operator GreaterThan(a,b:TV4d):boolean;inline;class operator GreaterThanOrEqual(a,b:TV4d):boolean;inline;class operator LessThan(a,b:TV4d):boolean;inline;class operator LessThanOrEqual(a,b:TV4d):boolean;inline;class operator Add(a,b:TV4d):TV4d;inline;class operator Subtract(a,b:TV4d):TV4d;inline;class operator Multiply(a,b:TV4d):TV4d;inline;class operator Multiply(a:TV4d;b:double):TV4d;inline;class operator Divide(a,b:TV4d):TV4d;inline;class operator Divide(a:TV4d;b:double):TV4d;inline;class operator Trunc(a:TV4d):TV4i;inline;class operator Round(a:TV4d):TV4i;inline;end;TV4dArray=array of TV4d;

{ define HCreators(t,typ)
function V2##t(const x,y:typ):TV2##t;
function V3##t(const x,y:typ;const z:typ=0):TV3##t;
function V4##t(const x,y:typ;const z:typ=0;const w:typ=0):TV4##t}
function V2i(const x,y:integer):TV2i;function V3i(const x,y:integer;const z:integer=0):TV3i;function V4i(const x,y:integer;const z:integer=0;const w:integer=0):TV4i;
function V2f(const x,y:single):TV2f;function V3f(const x,y:single;const z:single=0):TV3f;function V4f(const x,y:single;const z:single=0;const w:single=0):TV4f;
function V2d(const x,y:double):TV2d;function V3d(const x,y:double;const z:double=0):TV3d;function V4d(const x,y:double;const z:double=0;const w:double=0):TV4d;

{ define CommonFunctHdr(nt,typ)
function VLengthSqr(const a:TV##nt):typ;overload;
function VLengthManh(const a:TV##nt):typ;overload;
function VLength(const a:TV##nt):typ;overload;
function VDistSqr(const a,b:TV##nt):typ;overload;
function VDistManh(const a,b:TV##nt):typ;overload;
function VDist(const a,b:TV##nt):typ;overload;
function VAbs(const a:TV##nt):TV##nt;inline;overload;
procedure PVAbs(var a:TV##nt);overload;inline;overload;
function VLerp(const a,b:TV##nt;const p:single):TV##nt;overload;
function VMin(const a,b:TV##nt):TV##nt;overload;
procedure PVMin(var a:TV##nt;const b:TV##nt);overload;
function VMax(const a,b:TV##nt):TV##nt;overload;
procedure PVMax(var a:TV##nt;const b:TV##nt);overload
function VDot(const a,b:TV##nt):typ;overload;
function VCrossZ(const a,b:TV##nt):typ;overload}
function VLengthSqr(const a:TV2i):integer;overload;function VLengthManh(const a:TV2i):integer;overload;function VLength(const a:TV2i):integer;overload;function VDistSqr(const a,b:TV2i):integer;overload;function VDistManh(const a,b:TV2i):integer;overload;function VDist(const a,b:TV2i):integer;overload;function VAbs(const a:TV2i):TV2i;inline;overload;procedure PVAbs(var a:TV2i);overload;inline;overload;function VLerp(const a,b:TV2i;const p:single):TV2i;overload;function VMin(const a,b:TV2i):TV2i;overload;procedure PVMin(var a:TV2i;const b:TV2i);overload;function VMax(const a,b:TV2i):TV2i;overload;procedure PVMax(var a:TV2i;const b:TV2i);overload function VDot(const a,b:TV2i):integer;overload;function VCrossZ(const a,b:TV2i):integer;overload;
function VLengthSqr(const a:TV3i):integer;overload;function VLengthManh(const a:TV3i):integer;overload;function VLength(const a:TV3i):integer;overload;function VDistSqr(const a,b:TV3i):integer;overload;function VDistManh(const a,b:TV3i):integer;overload;function VDist(const a,b:TV3i):integer;overload;function VAbs(const a:TV3i):TV3i;inline;overload;procedure PVAbs(var a:TV3i);overload;inline;overload;function VLerp(const a,b:TV3i;const p:single):TV3i;overload;function VMin(const a,b:TV3i):TV3i;overload;procedure PVMin(var a:TV3i;const b:TV3i);overload;function VMax(const a,b:TV3i):TV3i;overload;procedure PVMax(var a:TV3i;const b:TV3i);overload function VDot(const a,b:TV3i):integer;overload;function VCrossZ(const a,b:TV3i):integer;overload;
function VLengthSqr(const a:TV4i):integer;overload;function VLengthManh(const a:TV4i):integer;overload;function VLength(const a:TV4i):integer;overload;function VDistSqr(const a,b:TV4i):integer;overload;function VDistManh(const a,b:TV4i):integer;overload;function VDist(const a,b:TV4i):integer;overload;function VAbs(const a:TV4i):TV4i;inline;overload;procedure PVAbs(var a:TV4i);overload;inline;overload;function VLerp(const a,b:TV4i;const p:single):TV4i;overload;function VMin(const a,b:TV4i):TV4i;overload;procedure PVMin(var a:TV4i;const b:TV4i);overload;function VMax(const a,b:TV4i):TV4i;overload;procedure PVMax(var a:TV4i;const b:TV4i);overload function VDot(const a,b:TV4i):integer;overload;function VCrossZ(const a,b:TV4i):integer;overload;

function VLengthSqr(const a:TV2f):single;overload;function VLengthManh(const a:TV2f):single;overload;function VLength(const a:TV2f):single;overload;function VDistSqr(const a,b:TV2f):single;overload;function VDistManh(const a,b:TV2f):single;overload;function VDist(const a,b:TV2f):single;overload;function VAbs(const a:TV2f):TV2f;inline;overload;procedure PVAbs(var a:TV2f);overload;inline;overload;function VLerp(const a,b:TV2f;const p:single):TV2f;overload;function VMin(const a,b:TV2f):TV2f;overload;procedure PVMin(var a:TV2f;const b:TV2f);overload;function VMax(const a,b:TV2f):TV2f;overload;procedure PVMax(var a:TV2f;const b:TV2f);overload function VDot(const a,b:TV2f):single;overload;function VCrossZ(const a,b:TV2f):single;overload;
function VLengthSqr(const a:TV3f):single;overload;function VLengthManh(const a:TV3f):single;overload;function VLength(const a:TV3f):single;overload;function VDistSqr(const a,b:TV3f):single;overload;function VDistManh(const a,b:TV3f):single;overload;function VDist(const a,b:TV3f):single;overload;function VAbs(const a:TV3f):TV3f;inline;overload;procedure PVAbs(var a:TV3f);overload;inline;overload;function VLerp(const a,b:TV3f;const p:single):TV3f;overload;function VMin(const a,b:TV3f):TV3f;overload;procedure PVMin(var a:TV3f;const b:TV3f);overload;function VMax(const a,b:TV3f):TV3f;overload;procedure PVMax(var a:TV3f;const b:TV3f);overload function VDot(const a,b:TV3f):single;overload;function VCrossZ(const a,b:TV3f):single;overload;
function VLengthSqr(const a:TV4f):single;overload;function VLengthManh(const a:TV4f):single;overload;function VLength(const a:TV4f):single;overload;function VDistSqr(const a,b:TV4f):single;overload;function VDistManh(const a,b:TV4f):single;overload;function VDist(const a,b:TV4f):single;overload;function VAbs(const a:TV4f):TV4f;inline;overload;procedure PVAbs(var a:TV4f);overload;inline;overload;function VLerp(const a,b:TV4f;const p:single):TV4f;overload;function VMin(const a,b:TV4f):TV4f;overload;procedure PVMin(var a:TV4f;const b:TV4f);overload;function VMax(const a,b:TV4f):TV4f;overload;procedure PVMax(var a:TV4f;const b:TV4f);overload function VDot(const a,b:TV4f):single;overload;function VCrossZ(const a,b:TV4f):single;overload;

function VLengthSqr(const a:TV2d):double;overload;function VLengthManh(const a:TV2d):double;overload;function VLength(const a:TV2d):double;overload;function VDistSqr(const a,b:TV2d):double;overload;function VDistManh(const a,b:TV2d):double;overload;function VDist(const a,b:TV2d):double;overload;function VAbs(const a:TV2d):TV2d;inline;overload;procedure PVAbs(var a:TV2d);overload;inline;overload;function VLerp(const a,b:TV2d;const p:single):TV2d;overload;function VMin(const a,b:TV2d):TV2d;overload;procedure PVMin(var a:TV2d;const b:TV2d);overload;function VMax(const a,b:TV2d):TV2d;overload;procedure PVMax(var a:TV2d;const b:TV2d);overload function VDot(const a,b:TV2d):double;overload;function VCrossZ(const a,b:TV2d):double;overload;
function VLengthSqr(const a:TV3d):double;overload;function VLengthManh(const a:TV3d):double;overload;function VLength(const a:TV3d):double;overload;function VDistSqr(const a,b:TV3d):double;overload;function VDistManh(const a,b:TV3d):double;overload;function VDist(const a,b:TV3d):double;overload;function VAbs(const a:TV3d):TV3d;inline;overload;procedure PVAbs(var a:TV3d);overload;inline;overload;function VLerp(const a,b:TV3d;const p:single):TV3d;overload;function VMin(const a,b:TV3d):TV3d;overload;procedure PVMin(var a:TV3d;const b:TV3d);overload;function VMax(const a,b:TV3d):TV3d;overload;procedure PVMax(var a:TV3d;const b:TV3d);overload function VDot(const a,b:TV3d):double;overload;function VCrossZ(const a,b:TV3d):double;overload;
function VLengthSqr(const a:TV4d):double;overload;function VLengthManh(const a:TV4d):double;overload;function VLength(const a:TV4d):double;overload;function VDistSqr(const a,b:TV4d):double;overload;function VDistManh(const a,b:TV4d):double;overload;function VDist(const a,b:TV4d):double;overload;function VAbs(const a:TV4d):TV4d;inline;overload;procedure PVAbs(var a:TV4d);overload;inline;overload;function VLerp(const a,b:TV4d;const p:single):TV4d;overload;function VMin(const a,b:TV4d):TV4d;overload;procedure PVMin(var a:TV4d;const b:TV4d);overload;function VMax(const a,b:TV4d):TV4d;overload;procedure PVMax(var a:TV4d;const b:TV4d);overload function VDot(const a,b:TV4d):double;overload;function VCrossZ(const a,b:TV4d):double;overload;

{ define FloatFunctHdr(nt,typ)
function VNormalize(const a:TV##nt):TV##nt;overload;
procedure PVNormalize(var a:TV##nt);overload}
function VNormalize(const a:TV2f):TV2f;overload;procedure PVNormalize(var a:TV2f);overload;
function VNormalize(const a:TV3f):TV3f;overload;procedure PVNormalize(var a:TV3f);overload;
function VNormalize(const a:TV4f):TV4f;overload;procedure PVNormalize(var a:TV4f);overload;

function VNormalize(const a:TV2d):TV2d;overload;procedure PVNormalize(var a:TV2d);overload;
function VNormalize(const a:TV3d):TV3d;overload;procedure PVNormalize(var a:TV3d);overload;
function VNormalize(const a:TV4d):TV4d;overload;procedure PVNormalize(var a:TV4d);overload;

{ define VCrossHdr(nt) function VCross(const a,b:TV##nt):TV##nt;overload}

function VCross(const a,b:TV3i):TV3i;overload;
function VCross(const a,b:TV4i):TV4i;overload;
function VCross(const a,b:TV3f):TV3f;overload;
function VCross(const a,b:TV4f):TV4f;overload;
function VCross(const a,b:TV3d):TV3d;overload;
function VCross(const a,b:TV4d):TV4d;overload;


//new stuff
function ToStr(const a:TV3f):ansistring;overload;
function ToStr(const a:TV2f):ansistring;overload;

implementation

function TV3i.GetCoord(i:integer):integer; begin case i of 0:result:=x; 1:result:=y; else result:=z end;end;
procedure TV3i.SetCoord(i:integer;a:integer); begin case i of 0:x:=a; 1:y:=a; else z:=a end;end;

function TV2f.GetCoord(i:integer):single; begin case i of 0:result:=x; else result:=y end;end;
procedure TV2f.SetCoord(i:integer;a:single); begin case i of 0:x:=a; else y:=a end;end;

function TV3f.GetCoord(i:integer):single; begin case i of 0:result:=x; 1:result:=y; else result:=z end;end;
procedure TV3f.SetCoord(i:integer;a:single); begin case i of 0:x:=a; 1:y:=a; else z:=a end;end;

function TV4f.GetCoord(i:integer):single; begin case i of 0:result:=x; 1:result:=y; 2:result:=z; else result:=w end;end;
procedure TV4f.SetCoord(i:integer;a:single); begin case i of 0:x:=a; 1:y:=a; 2:z:=a; else w:=a end;end;

function ToStr(const a:TV3f):ansistring;
begin
  result:=format('(%.3n, %.3n, %.3n)',[a.x ,a.y ,a.z]);
end;

function ToStr(const a:TV2f):ansistring;
begin
  result:=format('(%.3n, %.3n)',[a.x ,a.y]);
end;

//op overloading type implementations

class operator TV2i.Negative(a:TV2i):TV2i;begin result.x :=-a.x ;result.y :=-a.y ;end;class operator TV2i.Equal(a,b:TV2i):boolean;begin result:=(a.x =b.x )and(a.y =b.y );end;class operator TV2i.NotEqual(a,b:TV2i):boolean;begin result:=(a.x <>b.x )or(a.y <>b.y );end;class operator TV2i.GreaterThan(a,b:TV2i):boolean;begin result:=(a.x >b.x )and(a.y >b.y );end;class operator TV2i.GreaterThanOrEqual(a,b:TV2i):boolean;begin result:=(a.x >=b.x )and(a.y >=b.y );end;class operator TV2i.LessThan(a,b:TV2i):boolean;begin result:=(a.x <b.x )and(a.y <b.y );end;class operator TV2i.LessThanOrEqual(a,b:TV2i):boolean;begin result:=(a.x <=b.x )and(a.y <=b.y );end;class operator TV2i.Add(a,b:TV2i):TV2i;begin result.x :=a.x +b.x ;result.y :=a.y +b.y ;end;class operator TV2i.Subtract(a,b:TV2i):TV2i;begin result.x :=a.x -b.x ;result.y :=a.y -b.y ;end;class operator TV2i.Multiply(a,b:TV2i):TV2i;begin result.x :=a.x *b.x ;
result.y :=a.y *b.y ;end;class operator TV2i.Multiply(a:TV2i;b:integer):TV2i;begin result.x :=a.x *b;result.y :=a.y *b;end;class operator TV2i.IntDivide(a,b:TV2i):TV2i;begin result.x :=a.x div b.x ;result.y :=a.y div b.y ;end;class operator TV2i.IntDivide(a:TV2i;b:integer):TV2i;begin result.x :=a.x div b;result.y :=a.y div b;end;class operator TV2i.Modulus(a,b:TV2i):TV2i;begin result.x :=a.x mod b.x ;result.y :=a.y mod b.y ;end;class operator TV2i.Modulus(a:TV2i;b:integer):TV2i;begin result.x :=a.x mod b;result.y :=a.y mod b;end;class operator TV2i.LeftShift(a,b:TV2i):TV2i;begin result.x :=a.x shl b.x ;result.y :=a.y shl b.y ;end;class operator TV2i.LeftShift(a:TV2i;b:integer):TV2i;begin result.x :=a.x shl b;result.y :=a.y shl b;end;class operator TV2i.RightShift(a,b:TV2i):TV2i;begin result.x :=a.x shr b.x ;result.y :=a.y shr b.y ;end;class operator TV2i.RightShift(a:TV2i;b:integer):TV2i;begin result.
x :=a.x shr b;result.y :=a.y shr b;end;class operator TV2i.BitwiseAnd(a,b:TV2i):TV2i;begin result.x :=a.x and b.x ;result.y :=a.y and b.y ;end;class operator TV2i.BitwiseAnd(a:TV2i;b:integer):TV2i;begin result.x :=a.x and b;result.y :=a.y and b;end;class operator TV2i.BitwiseOr(a,b:TV2i):TV2i;begin result.x :=a.x or b.x ;result.y :=a.y or b.y ;end;class operator TV2i.BitwiseOr(a:TV2i;b:integer):TV2i;begin result.x :=a.x or b;result.y :=a.y or b;end;class operator TV2i.BitwiseXor(a,b:TV2i):TV2i;begin result.x :=a.x xor b.x ;result.y :=a.y xor b.y ;end;class operator TV2i.BitwiseXor(a:TV2i;b:integer):TV2i;begin result.x :=a.x xor b;result.y :=a.y xor b;end;
class operator TV3i.Negative(a:TV3i):TV3i;begin result.x :=-a.x ;result.y :=-a.y ;result.z :=-a.z ;end;class operator TV3i.Equal(a,b:TV3i):boolean;begin result:=(a.x =b.x )and(a.y =b.y )and(a.z =b.z );end;class operator TV3i.NotEqual(a,b:TV3i):boolean;begin result:=(a.x <>b.x )or(a.y <>b.y )or(a.z <>b.z );end;class operator TV3i.GreaterThan(a,b:TV3i):boolean;begin result:=(a.x >b.x )and(a.y >b.y )and(a.z >b.z );end;class operator TV3i.GreaterThanOrEqual(a,b:TV3i):boolean;begin result:=(a.x >=b.x )and(a.y >=b.y )and(a.z >=b.z );end;class operator TV3i.LessThan(a,b:TV3i):boolean;begin result:=(a.x <b.x )and(a.y <b.y )and(a.z <b.z );end;class operator TV3i.LessThanOrEqual(a,b:TV3i):boolean;begin result:=(a.x <=b.x )and(a.y <=b.y )and(a.z <=b.z );end;class operator TV3i.Add(a,b:TV3i):TV3i;begin result.x :=a.x +b.x ;result.y :=a.y +b.y ;result.z :=a.z +b.z ;end;class operator TV3i.
Subtract(a,b:TV3i):TV3i;begin result.x :=a.x -b.x ;result.y :=a.y -b.y ;result.z :=a.z -b.z ;end;class operator TV3i.Multiply(a,b:TV3i):TV3i;begin result.x :=a.x *b.x ;result.y :=a.y *b.y ;result.z :=a.z *b.z ;end;class operator TV3i.Multiply(a:TV3i;b:integer):TV3i;begin result.x :=a.x *b;result.y :=a.y *b;result.z :=a.z *b;end;class operator TV3i.IntDivide(a,b:TV3i):TV3i;begin result.x :=a.x div b.x ;result.y :=a.y div b.y ;result.z :=a.z div b.z ;end;class operator TV3i.IntDivide(a:TV3i;b:integer):TV3i;begin result.x :=a.x div b;result.y :=a.y div b;result.z :=a.z div b;end;class operator TV3i.Modulus(a,b:TV3i):TV3i;begin result.x :=a.x mod b.x ;result.y :=a.y mod b.y ;result.z :=a.z mod b.z ;end;class operator TV3i.Modulus(a:TV3i;b:integer):TV3i;begin result.x :=a.x mod b;result.y :=a.y mod b;result.z :=a.z mod b;end;class operator TV3i.LeftShift(a,b:TV3i):TV3i;begin result.x
:=a.x shl b.x ;result.y :=a.y shl b.y ;result.z :=a.z shl b.z ;end;class operator TV3i.LeftShift(a:TV3i;b:integer):TV3i;begin result.x :=a.x shl b;result.y :=a.y shl b;result.z :=a.z shl b;end;class operator TV3i.RightShift(a,b:TV3i):TV3i;begin result.x :=a.x shr b.x ;result.y :=a.y shr b.y ;result.z :=a.z shr b.z ;end;class operator TV3i.RightShift(a:TV3i;b:integer):TV3i;begin result.x :=a.x shr b;result.y :=a.y shr b;result.z :=a.z shr b;end;class operator TV3i.BitwiseAnd(a,b:TV3i):TV3i;begin result.x :=a.x and b.x ;result.y :=a.y and b.y ;result.z :=a.z and b.z ;end;class operator TV3i.BitwiseAnd(a:TV3i;b:integer):TV3i;begin result.x :=a.x and b;result.y :=a.y and b;result.z :=a.z and b;end;class operator TV3i.BitwiseOr(a,b:TV3i):TV3i;begin result.x :=a.x or b.x ;result.y :=a.y or b.y ;result.z :=a.z or b.z ;end;class operator TV3i.BitwiseOr(a:TV3i;b:integer):TV3i;begin result
.x :=a.x or b;result.y :=a.y or b;result.z :=a.z or b;end;class operator TV3i.BitwiseXor(a,b:TV3i):TV3i;begin result.x :=a.x xor b.x ;result.y :=a.y xor b.y ;result.z :=a.z xor b.z ;end;class operator TV3i.BitwiseXor(a:TV3i;b:integer):TV3i;begin result.x :=a.x xor b;result.y :=a.y xor b;result.z :=a.z xor b;end;
class operator TV4i.Negative(a:TV4i):TV4i;begin result.x :=-a.x ;result.y :=-a.y ;result.z :=-a.z ;result.w :=-a.w ;end;class operator TV4i.Equal(a,b:TV4i):boolean;begin result:=(a.x =b.x )and(a.y =b.y )and(a.z =b.z )and(a.w =b.w );end;class operator TV4i.NotEqual(a,b:TV4i):boolean;begin result:=(a.x <>b.x )or(a.y <>b.y )or(a.z <>b.z )or(a.w <>b.w );end;class operator TV4i.GreaterThan(a,b:TV4i):boolean;begin result:=(a.x >b.x )and(a.y >b.y )and(a.z >b.z )and(a.w >b.w );end;class operator TV4i.GreaterThanOrEqual(a,b:TV4i):boolean;begin result:=(a.x >=b.x )and(a.y >=b.y )and(a.z >=b.z )and(a.w >=b.w );end;class operator TV4i.LessThan(a,b:TV4i):boolean;begin result:=(a.x <b.x )and(a.y <b.y )and(a.z <b.z )and(a.w <b.w );end;class operator TV4i.LessThanOrEqual(a,b:TV4i):boolean;begin result:=(a.x <=b.x )and(a.y <=b.y )and(a.z <=b.z )and(a.w <=b.w );end;class operator TV4i.Add(
a,b:TV4i):TV4i;begin result.x :=a.x +b.x ;result.y :=a.y +b.y ;result.z :=a.z +b.z ;result.w :=a.w +b.w ;end;class operator TV4i.Subtract(a,b:TV4i):TV4i;begin result.x :=a.x -b.x ;result.y :=a.y -b.y ;result.z :=a.z -b.z ;result.w :=a.w -b.w ;end;class operator TV4i.Multiply(a,b:TV4i):TV4i;begin result.x :=a.x *b.x ;result.y :=a.y *b.y ;result.z :=a.z *b.z ;result.w :=a.w *b.w ;end;class operator TV4i.Multiply(a:TV4i;b:integer):TV4i;begin result.x :=a.x *b;result.y :=a.y *b;result.z :=a.z *b;result.w :=a.w *b;end;class operator TV4i.IntDivide(a,b:TV4i):TV4i;begin result.x :=a.x div b.x ;result.y :=a.y div b.y ;result.z :=a.z div b.z ;result.w :=a.w div b.w ;end;class operator TV4i.IntDivide(a:TV4i;b:integer):TV4i;begin result.x :=a.x div b;result.y :=a.y div b;result.z :=a.z div b;result.w :=a.w div b;end;class operator TV4i.Modulus(a,b:TV4i):TV4i;begin result
.x :=a.x mod b.x ;result.y :=a.y mod b.y ;result.z :=a.z mod b.z ;result.w :=a.w mod b.w ;end;class operator TV4i.Modulus(a:TV4i;b:integer):TV4i;begin result.x :=a.x mod b;result.y :=a.y mod b;result.z :=a.z mod b;result.w :=a.w mod b;end;class operator TV4i.LeftShift(a,b:TV4i):TV4i;begin result.x :=a.x shl b.x ;result.y :=a.y shl b.y ;result.z :=a.z shl b.z ;result.w :=a.w shl b.w ;end;class operator TV4i.LeftShift(a:TV4i;b:integer):TV4i;begin result.x :=a.x shl b;result.y :=a.y shl b;result.z :=a.z shl b;result.w :=a.w shl b;end;class operator TV4i.RightShift(a,b:TV4i):TV4i;begin result.x :=a.x shr b.x ;result.y :=a.y shr b.y ;result.z :=a.z shr b.z ;result.w :=a.w shr b.w ;end;class operator TV4i.RightShift(a:TV4i;b:integer):TV4i;begin result.x :=a.x shr b;result.y :=a.y shr b;result.z :=a.z shr b;result.w :=a.w shr b;end;class operator TV4i.BitwiseAnd(a,b:TV4i):
TV4i;begin result.x :=a.x and b.x ;result.y :=a.y and b.y ;result.z :=a.z and b.z ;result.w :=a.w and b.w ;end;class operator TV4i.BitwiseAnd(a:TV4i;b:integer):TV4i;begin result.x :=a.x and b;result.y :=a.y and b;result.z :=a.z and b;result.w :=a.w and b;end;class operator TV4i.BitwiseOr(a,b:TV4i):TV4i;begin result.x :=a.x or b.x ;result.y :=a.y or b.y ;result.z :=a.z or b.z ;result.w :=a.w or b.w ;end;class operator TV4i.BitwiseOr(a:TV4i;b:integer):TV4i;begin result.x :=a.x or b;result.y :=a.y or b;result.z :=a.z or b;result.w :=a.w or b;end;class operator TV4i.BitwiseXor(a,b:TV4i):TV4i;begin result.x :=a.x xor b.x ;result.y :=a.y xor b.y ;result.z :=a.z xor b.z ;result.w :=a.w xor b.w ;end;class operator TV4i.BitwiseXor(a:TV4i;b:integer):TV4i;begin result.x :=a.x xor b;result.y :=a.y xor b;result.z :=a.z xor b;result.w :=a.w xor b;end;

class operator TV2f.Implicit(a:TV2i):TV2f;begin result.x :=a.x ;result.y :=a.y ;end;class operator TV2f.Negative(a:TV2f):TV2f;begin result.x :=-a.x ;result.y :=-a.y ;end;class operator TV2f.Equal(a,b:TV2f):boolean;begin result:=(a.x =b.x )and(a.y =b.y );end;class operator TV2f.NotEqual(a,b:TV2f):boolean;begin result:=(a.x <>b.x )or(a.y <>b.y );end;class operator TV2f.GreaterThan(a,b:TV2f):boolean;begin result:=(a.x >b.x )and(a.y >b.y );end;class operator TV2f.GreaterThanOrEqual(a,b:TV2f):boolean;begin result:=(a.x >=b.x )and(a.y >=b.y );end;class operator TV2f.LessThan(a,b:TV2f):boolean;begin result:=(a.x <b.x )and(a.y <b.y );end;class operator TV2f.LessThanOrEqual(a,b:TV2f):boolean;begin result:=(a.x <=b.x )and(a.y <=b.y );end;class operator TV2f.Add(a,b:TV2f):TV2f;begin result.x :=a.x +b.x ;result.y :=a.y +b.y ;end;class operator TV2f.Subtract(a,b:TV2f):TV2f;begin result.x :=a.x -b.x ;result.y :=a.
y-b.y ;end;class operator TV2f.Multiply(a,b:TV2f):TV2f;begin result.x :=a.x *b.x ;result.y :=a.y *b.y ;end;class operator TV2f.Multiply(a:TV2f;b:single):TV2f;begin result.x :=a.x *b;result.y :=a.y *b;end;class operator TV2f.Divide(a,b:TV2f):TV2f;begin result.x :=a.x /b.x ;result.y :=a.y /b.y ;end;class operator TV2f.Divide(a:TV2f;b:single):TV2f;begin result.x :=a.x /b;result.y :=a.y /b;end;class operator TV2f.Trunc(a:TV2f):TV2i;begin result.x :=Trunc(a.x );result.y :=Trunc(a.y );end;class operator TV2f.Round(a:TV2f):TV2i;begin result.x :=Round(a.x );result.y :=Round(a.y );end;
class operator TV3f.Implicit(a:TV3i):TV3f;begin result.x :=a.x ;result.y :=a.y ;result.z :=a.z ;end;class operator TV3f.Negative(a:TV3f):TV3f;begin result.x :=-a.x ;result.y :=-a.y ;result.z :=-a.z ;end;class operator TV3f.Equal(a,b:TV3f):boolean;begin result:=(a.x =b.x )and(a.y =b.y )and(a.z =b.z );end;class operator TV3f.NotEqual(a,b:TV3f):boolean;begin result:=(a.x <>b.x )or(a.y <>b.y )or(a.z <>b.z );end;class operator TV3f.GreaterThan(a,b:TV3f):boolean;begin result:=(a.x >b.x )and(a.y >b.y )and(a.z >b.z );end;class operator TV3f.GreaterThanOrEqual(a,b:TV3f):boolean;begin result:=(a.x >=b.x )and(a.y >=b.y )and(a.z >=b.z );end;class operator TV3f.LessThan(a,b:TV3f):boolean;begin result:=(a.x <b.x )and(a.y <b.y )and(a.z <b.z );end;class operator TV3f.LessThanOrEqual(a,b:TV3f):boolean;begin result:=(a.x <=b.x )and(a.y <=b.y )and(a.z <=b.z );end;class operator TV3f.Add(a,b:TV3f):TV3f;begin
result.x :=a.x +b.x ;result.y :=a.y +b.y ;result.z :=a.z +b.z ;end;class operator TV3f.Subtract(a,b:TV3f):TV3f;begin result.x :=a.x -b.x ;result.y :=a.y -b.y ;result.z :=a.z -b.z ;end;class operator TV3f.Multiply(a,b:TV3f):TV3f;begin result.x :=a.x *b.x ;result.y :=a.y *b.y ;result.z :=a.z *b.z ;end;class operator TV3f.Multiply(a:TV3f;b:single):TV3f;begin result.x :=a.x *b;result.y :=a.y *b;result.z :=a.z *b;end;class operator TV3f.Divide(a,b:TV3f):TV3f;begin result.x :=a.x /b.x ;result.y :=a.y /b.y ;result.z :=a.z /b.z ;end;class operator TV3f.Divide(a:TV3f;b:single):TV3f;begin result.x :=a.x /b;result.y :=a.y /b;result.z :=a.z /b;end;class operator TV3f.Trunc(a:TV3f):TV3i;begin result.x :=Trunc(a.x );result.y :=Trunc(a.y );result.z :=Trunc(a.z );end;class operator TV3f.Round(a:TV3f):TV3i;begin result.x :=Round(a.x );result.y :=Round(a.y );result.z :=Round(a.z );end;
class operator TV4f.Implicit(a:TV4i):TV4f;begin result.x :=a.x ;result.y :=a.y ;result.z :=a.z ;result.w :=a.w ;end;class operator TV4f.Negative(a:TV4f):TV4f;begin result.x :=-a.x ;result.y :=-a.y ;result.z :=-a.z ;result.w :=-a.w ;end;class operator TV4f.Equal(a,b:TV4f):boolean;begin result:=(a.x =b.x )and(a.y =b.y )and(a.z =b.z )and(a.w =b.w );end;class operator TV4f.NotEqual(a,b:TV4f):boolean;begin result:=(a.x <>b.x )or(a.y <>b.y )or(a.z <>b.z )or(a.w <>b.w );end;class operator TV4f.GreaterThan(a,b:TV4f):boolean;begin result:=(a.x >b.x )and(a.y >b.y )and(a.z >b.z )and(a.w >b.w );end;class operator TV4f.GreaterThanOrEqual(a,b:TV4f):boolean;begin result:=(a.x >=b.x )and(a.y >=b.y )and(a.z >=b.z )and(a.w >=b.w );end;class operator TV4f.LessThan(a,b:TV4f):boolean;begin result:=(a.x <b.x )and(a.y <b.y )and(a.z <b.z )and(a.w <b.w );end;class operator TV4f.LessThanOrEqual(a,
b:TV4f):boolean;begin result:=(a.x <=b.x )and(a.y <=b.y )and(a.z <=b.z )and(a.w <=b.w );end;class operator TV4f.Add(a,b:TV4f):TV4f;begin result.x :=a.x +b.x ;result.y :=a.y +b.y ;result.z :=a.z +b.z ;result.w :=a.w +b.w ;end;class operator TV4f.Subtract(a,b:TV4f):TV4f;begin result.x :=a.x -b.x ;result.y :=a.y -b.y ;result.z :=a.z -b.z ;result.w :=a.w -b.w ;end;class operator TV4f.Multiply(a,b:TV4f):TV4f;begin result.x :=a.x *b.x ;result.y :=a.y *b.y ;result.z :=a.z *b.z ;result.w :=a.w *b.w ;end;class operator TV4f.Multiply(a:TV4f;b:single):TV4f;begin result.x :=a.x *b;result.y :=a.y *b;result.z :=a.z *b;result.w :=a.w *b;end;class operator TV4f.Divide(a,b:TV4f):TV4f;begin result.x :=a.x /b.x ;result.y :=a.y /b.y ;result.z :=a.z /b.z ;result.w :=a.w /b.w ;end;class operator TV4f.Divide(a:TV4f;b:single):TV4f;begin result.x :=a.x /b;result.y :=a.y /b;
result.z :=a.z /b;result.w :=a.w /b;end;class operator TV4f.Trunc(a:TV4f):TV4i;begin result.x :=Trunc(a.x );result.y :=Trunc(a.y );result.z :=Trunc(a.z );result.w :=Trunc(a.w );end;class operator TV4f.Round(a:TV4f):TV4i;begin result.x :=Round(a.x );result.y :=Round(a.y );result.z :=Round(a.z );result.w :=Round(a.w );end;

class operator TV2d.Implicit(a:TV2i):TV2d;begin result.x :=a.x ;result.y :=a.y ;end;class operator TV2d.Negative(a:TV2d):TV2d;begin result.x :=-a.x ;result.y :=-a.y ;end;class operator TV2d.Equal(a,b:TV2d):boolean;begin result:=(a.x =b.x )and(a.y =b.y );end;class operator TV2d.NotEqual(a,b:TV2d):boolean;begin result:=(a.x <>b.x )or(a.y <>b.y );end;class operator TV2d.GreaterThan(a,b:TV2d):boolean;begin result:=(a.x >b.x )and(a.y >b.y );end;class operator TV2d.GreaterThanOrEqual(a,b:TV2d):boolean;begin result:=(a.x >=b.x )and(a.y >=b.y );end;class operator TV2d.LessThan(a,b:TV2d):boolean;begin result:=(a.x <b.x )and(a.y <b.y );end;class operator TV2d.LessThanOrEqual(a,b:TV2d):boolean;begin result:=(a.x <=b.x )and(a.y <=b.y );end;class operator TV2d.Add(a,b:TV2d):TV2d;begin result.x :=a.x +b.x ;result.y :=a.y +b.y ;end;class operator TV2d.Subtract(a,b:TV2d):TV2d;begin result.x :=a.x -b.x ;result.y :=a.
y-b.y ;end;class operator TV2d.Multiply(a,b:TV2d):TV2d;begin result.x :=a.x *b.x ;result.y :=a.y *b.y ;end;class operator TV2d.Multiply(a:TV2d;b:double):TV2d;begin result.x :=a.x *b;result.y :=a.y *b;end;class operator TV2d.Divide(a,b:TV2d):TV2d;begin result.x :=a.x /b.x ;result.y :=a.y /b.y ;end;class operator TV2d.Divide(a:TV2d;b:double):TV2d;begin result.x :=a.x /b;result.y :=a.y /b;end;class operator TV2d.Trunc(a:TV2d):TV2i;begin result.x :=Trunc(a.x );result.y :=Trunc(a.y );end;class operator TV2d.Round(a:TV2d):TV2i;begin result.x :=Round(a.x );result.y :=Round(a.y );end;
class operator TV3d.Implicit(a:TV3i):TV3d;begin result.x :=a.x ;result.y :=a.y ;result.z :=a.z ;end;class operator TV3d.Negative(a:TV3d):TV3d;begin result.x :=-a.x ;result.y :=-a.y ;result.z :=-a.z ;end;class operator TV3d.Equal(a,b:TV3d):boolean;begin result:=(a.x =b.x )and(a.y =b.y )and(a.z =b.z );end;class operator TV3d.NotEqual(a,b:TV3d):boolean;begin result:=(a.x <>b.x )or(a.y <>b.y )or(a.z <>b.z );end;class operator TV3d.GreaterThan(a,b:TV3d):boolean;begin result:=(a.x >b.x )and(a.y >b.y )and(a.z >b.z );end;class operator TV3d.GreaterThanOrEqual(a,b:TV3d):boolean;begin result:=(a.x >=b.x )and(a.y >=b.y )and(a.z >=b.z );end;class operator TV3d.LessThan(a,b:TV3d):boolean;begin result:=(a.x <b.x )and(a.y <b.y )and(a.z <b.z );end;class operator TV3d.LessThanOrEqual(a,b:TV3d):boolean;begin result:=(a.x <=b.x )and(a.y <=b.y )and(a.z <=b.z );end;class operator TV3d.Add(a,b:TV3d):TV3d;begin
result.x :=a.x +b.x ;result.y :=a.y +b.y ;result.z :=a.z +b.z ;end;class operator TV3d.Subtract(a,b:TV3d):TV3d;begin result.x :=a.x -b.x ;result.y :=a.y -b.y ;result.z :=a.z -b.z ;end;class operator TV3d.Multiply(a,b:TV3d):TV3d;begin result.x :=a.x *b.x ;result.y :=a.y *b.y ;result.z :=a.z *b.z ;end;class operator TV3d.Multiply(a:TV3d;b:double):TV3d;begin result.x :=a.x *b;result.y :=a.y *b;result.z :=a.z *b;end;class operator TV3d.Divide(a,b:TV3d):TV3d;begin result.x :=a.x /b.x ;result.y :=a.y /b.y ;result.z :=a.z /b.z ;end;class operator TV3d.Divide(a:TV3d;b:double):TV3d;begin result.x :=a.x /b;result.y :=a.y /b;result.z :=a.z /b;end;class operator TV3d.Trunc(a:TV3d):TV3i;begin result.x :=Trunc(a.x );result.y :=Trunc(a.y );result.z :=Trunc(a.z );end;class operator TV3d.Round(a:TV3d):TV3i;begin result.x :=Round(a.x );result.y :=Round(a.y );result.z :=Round(a.z );end;
class operator TV4d.Implicit(a:TV4i):TV4d;begin result.x :=a.x ;result.y :=a.y ;result.z :=a.z ;result.w :=a.w ;end;class operator TV4d.Negative(a:TV4d):TV4d;begin result.x :=-a.x ;result.y :=-a.y ;result.z :=-a.z ;result.w :=-a.w ;end;class operator TV4d.Equal(a,b:TV4d):boolean;begin result:=(a.x =b.x )and(a.y =b.y )and(a.z =b.z )and(a.w =b.w );end;class operator TV4d.NotEqual(a,b:TV4d):boolean;begin result:=(a.x <>b.x )or(a.y <>b.y )or(a.z <>b.z )or(a.w <>b.w );end;class operator TV4d.GreaterThan(a,b:TV4d):boolean;begin result:=(a.x >b.x )and(a.y >b.y )and(a.z >b.z )and(a.w >b.w );end;class operator TV4d.GreaterThanOrEqual(a,b:TV4d):boolean;begin result:=(a.x >=b.x )and(a.y >=b.y )and(a.z >=b.z )and(a.w >=b.w );end;class operator TV4d.LessThan(a,b:TV4d):boolean;begin result:=(a.x <b.x )and(a.y <b.y )and(a.z <b.z )and(a.w <b.w );end;class operator TV4d.LessThanOrEqual(a,
b:TV4d):boolean;begin result:=(a.x <=b.x )and(a.y <=b.y )and(a.z <=b.z )and(a.w <=b.w );end;class operator TV4d.Add(a,b:TV4d):TV4d;begin result.x :=a.x +b.x ;result.y :=a.y +b.y ;result.z :=a.z +b.z ;result.w :=a.w +b.w ;end;class operator TV4d.Subtract(a,b:TV4d):TV4d;begin result.x :=a.x -b.x ;result.y :=a.y -b.y ;result.z :=a.z -b.z ;result.w :=a.w -b.w ;end;class operator TV4d.Multiply(a,b:TV4d):TV4d;begin result.x :=a.x *b.x ;result.y :=a.y *b.y ;result.z :=a.z *b.z ;result.w :=a.w *b.w ;end;class operator TV4d.Multiply(a:TV4d;b:double):TV4d;begin result.x :=a.x *b;result.y :=a.y *b;result.z :=a.z *b;result.w :=a.w *b;end;class operator TV4d.Divide(a,b:TV4d):TV4d;begin result.x :=a.x /b.x ;result.y :=a.y /b.y ;result.z :=a.z /b.z ;result.w :=a.w /b.w ;end;class operator TV4d.Divide(a:TV4d;b:double):TV4d;begin result.x :=a.x /b;result.y :=a.y /b;
result.z :=a.z /b;result.w :=a.w /b;end;class operator TV4d.Trunc(a:TV4d):TV4i;begin result.x :=Trunc(a.x );result.y :=Trunc(a.y );result.z :=Trunc(a.z );result.w :=Trunc(a.w );end;class operator TV4d.Round(a:TV4d):TV4i;begin result.x :=Round(a.x );result.y :=Round(a.y );result.z :=Round(a.z );result.w :=Round(a.w );end;

{ define BCreators(t,typ)
function V2##t(const x,y:typ):TV2##t;begin result.x :=x;result.y :=y;end;
function V3##t(const x,y:typ;const z:typ=0):TV3##t;begin result.x :=x;result.y :=y;result.z :=z;end;
function V4##t(const x,y:typ;const z:typ=0;const w:typ=0):TV4##t;begin result.x :=x;result.y :=y;result.z :=z;result.w :=w;end}
function V2i(const x,y:integer):TV2i;begin result.x :=x;result.y :=y;end;function V3i(const x,y:integer;const z:integer=0):TV3i;begin result.x :=x;result.y :=y;result.z :=z;end;function V4i(const x,y:integer;const z:integer=0;const w:integer=0):TV4i;begin result.x :=x;result.y :=y;result.z :=z;result.w :=w;end;
function V2f(const x,y:single):TV2f;begin result.x :=x;result.y :=y;end;function V3f(const x,y:single;const z:single=0):TV3f;begin result.x :=x;result.y :=y;result.z :=z;end;function V4f(const x,y:single;const z:single=0;const w:single=0):TV4f;begin result.x :=x;result.y :=y;result.z :=z;result.w :=w;end;
function V2d(const x,y:double):TV2d;begin result.x :=x;result.y :=y;end;function V3d(const x,y:double;const z:double=0):TV3d;begin result.x :=x;result.y :=y;result.z :=z;end;function V4d(const x,y:double;const z:double=0;const w:double=0):TV4d;begin result.x :=x;result.y :=y;result.z :=z;result.w :=w;end;

{ define CommonFunct(n,t,typ,rnd)
function VLengthSqr(const a:TV##n##t):typ;  begin result:=concat##n(a.V[num]*a.V[num],+);end;
function VLengthManh(const a:TV##n##t):typ; begin result:=concat##n(abs(a.V[num]),+);end;
function VLength(const a:TV##n##t):typ;     begin result:=rnd(sqrt(concat##n(a.V[num]*a.V[num],+)));end;
function VDistSqr(const a,b:TV##n##t):typ;  begin result:=concat##n(sqr(a.V[num]-b.V[num]),+);end;
function VDistManh(const a,b:TV##n##t):typ; begin result:=concat##n(abs(a.V[num]-b.V[num]),+);end;
function VDist(const a,b:TV##n##t):typ;     begin result:=rnd(sqrt(concat##n(sqr(a.V[num]-b.V[num]),+)));end;
function VAbs(const a:TV##n##t):TV##n##t;   begin concat##n(result.V[num]:=abs(a.V[num]),;);end;
procedure PVAbs(var a:TV##n##t);            begin concat##n(if a.V[num]<0 then a.V[num]:=-a.V[num],;);end;
function VLerp(const a,b:TV##n##t;const p:single):TV##n##t;begin concat##n(result.v[num]:=a.v[num]+rnd((b.v[num]-a.v[num])*p),;);end;
function VMin(const a,b:TV##n##t):TV##n##t; begin concat##n(if b.v[num]<a.v[num]then result.v[num]:=b.v[num]else result.v[num]:=a.v[num],;);end;
procedure PVMin(var a:TV##n##t;const b:TV##n##t); begin concat##n(if b.v[num]<a.v[num]then a.v[num]:=b.v[num],;);end;
function VMax(const a,b:TV##n##t):TV##n##t; begin concat##n(if b.v[num]>a.v[num]then result.v[num]:=b.v[num]else result.v[num]:=a.v[num],;);end;
procedure PVMax(var a:TV##n##t;const b:TV##n##t); begin concat##n(if b.v[num]>a.v[num]then a.v[num]:=b.v[num],;);end;
function VDot(const a,b:TV##n##t):typ;      begin result:=concat##n(a.V[num]*b.V[num],+);end;
function VCrossZ(const a,b:TV##n##t):typ;   begin result:=a.x *b.y -a.y *b.x end}
function VLengthSqr(const a:TV2i):integer;begin result:=a.x *a.x +a.y *a.y ;end;function VLengthManh(const a:TV2i):integer;begin result:=abs(a.x )+abs(a.y );end;function VLength(const a:TV2i):integer;begin result:=round(sqrt(a.x *a.x +a.y *a.y ));end;function VDistSqr(const a,b:TV2i):integer;begin result:=sqr(a.x -b.x )+sqr(a.y -b.y );end;function VDistManh(const a,b:TV2i):integer;begin result:=abs(a.x -b.x )+abs(a.y -b.y );end;function VDist(const a,b:TV2i):integer;begin result:=round(sqrt(sqr(a.x -b.x )+sqr(a.y -b.y )));end;function VAbs(const a:TV2i):TV2i;begin result.x :=abs(a.x );result.y :=abs(a.y );end;procedure PVAbs(var a:TV2i);begin if a.x <0 then a.x :=-a.x ;if a.y <0 then a.y :=-a.y ;end;function VLerp(const a,b:TV2i;const p:single):TV2i;begin result.x :=a.x +round((b.x -a.x )*p);result.y :=a.y +round((b.y -a.y )*p);end;function VMin(const a,b:TV2i):TV2i;begin if b.x <a.x then result.x :=
b.x else result.x :=a.x ;if b.y <a.y then result.y :=b.y else result.y :=a.y ;end;procedure PVMin(var a:TV2i;const b:TV2i);begin if b.x <a.x then a.x :=b.x ;if b.y <a.y then a.y :=b.y ;end;function VMax(const a,b:TV2i):TV2i;begin if b.x >a.x then result.x :=b.x else result.x :=a.x ;if b.y >a.y then result.y :=b.y else result.y :=a.y ;end;procedure PVMax(var a:TV2i;const b:TV2i);begin if b.x >a.x then a.x :=b.x ;if b.y >a.y then a.y :=b.y ;end;function VDot(const a,b:TV2i):integer;begin result:=a.x *b.x +a.y *b.y ;end;function VCrossZ(const a,b:TV2i):integer;begin result:=a.x *b.y -a.y *b.x end;
function VLengthSqr(const a:TV3i):integer;begin result:=a.x *a.x +a.y *a.y +a.z *a.z ;end;function VLengthManh(const a:TV3i):integer;begin result:=abs(a.x )+abs(a.y )+abs(a.z );end;function VLength(const a:TV3i):integer;begin result:=round(sqrt(a.x *a.x +a.y *a.y +a.z *a.z ));end;function VDistSqr(const a,b:TV3i):integer;begin result:=sqr(a.x -b.x )+sqr(a.y -b.y )+sqr(a.z -b.z );end;function VDistManh(const a,b:TV3i):integer;begin result:=abs(a.x -b.x )+abs(a.y -b.y )+abs(a.z -b.z );end;function VDist(const a,b:TV3i):integer;begin result:=round(sqrt(sqr(a.x -b.x )+sqr(a.y -b.y )+sqr(a.z -b.z )));end;function VAbs(const a:TV3i):TV3i;begin result.x :=abs(a.x );result.y :=abs(a.y );result.z :=abs(a.z );end;procedure PVAbs(var a:TV3i);begin if a.x <0 then a.x :=-a.x ;if a.y <0 then a.y :=-a.y ;if a.z <0 then a.z :=-a.z ;end;function VLerp(const a,b:TV3i;const p:single):TV3i;begin result.x :=a
.x +round((b.x -a.x )*p);result.y :=a.y +round((b.y -a.y )*p);result.z :=a.z +round((b.z -a.z )*p);end;function VMin(const a,b:TV3i):TV3i;begin if b.x <a.x then result.x :=b.x else result.x :=a.x ;if b.y <a.y then result.y :=b.y else result.y :=a.y ;if b.z <a.z then result.z :=b.z else result.z :=a.z ;end;procedure PVMin(var a:TV3i;const b:TV3i);begin if b.x <a.x then a.x :=b.x ;if b.y <a.y then a.y :=b.y ;if b.z <a.z then a.z :=b.z ;end;function VMax(const a,b:TV3i):TV3i;begin if b.x >a.x then result.x :=b.x else result.x :=a.x ;if b.y >a.y then result.y :=b.y else result.y :=a.y ;if b.z >a.z then result.z :=b.z else result.z :=a.z ;end;procedure PVMax(var a:TV3i;const b:TV3i);begin if b.x >a.x then a.x :=b.x ;if b.y >a.y then a.y :=b.y ;if b.z >a.z then a.z :=b.z ;end;function VDot(const a,b:TV3i):integer;begin result:=a.x *b.x +a.y *b.
y+a.z *b.z ;end;function VCrossZ(const a,b:TV3i):integer;begin result:=a.x *b.y -a.y *b.x end;
function VLengthSqr(const a:TV4i):integer;begin result:=a.x *a.x +a.y *a.y +a.z *a.z +a.w *a.w ;end;function VLengthManh(const a:TV4i):integer;begin result:=abs(a.x )+abs(a.y )+abs(a.z )+abs(a.w );end;function VLength(const a:TV4i):integer;begin result:=round(sqrt(a.x *a.x +a.y *a.y +a.z *a.z +a.w *a.w ));end;function VDistSqr(const a,b:TV4i):integer;begin result:=sqr(a.x -b.x )+sqr(a.y -b.y )+sqr(a.z -b.z )+sqr(a.w -b.w );end;function VDistManh(const a,b:TV4i):integer;begin result:=abs(a.x -b.x )+abs(a.y -b.y )+abs(a.z -b.z )+abs(a.w -b.w );end;function VDist(const a,b:TV4i):integer;begin result:=round(sqrt(sqr(a.x -b.x )+sqr(a.y -b.y )+sqr(a.z -b.z )+sqr(a.w -b.w )));end;function VAbs(const a:TV4i):TV4i;begin result.x :=abs(a.x );result.y :=abs(a.y );result.z :=abs(a.z );result.w :=abs(a.w );end;procedure PVAbs(var a:TV4i);begin if a.x <0 then a.x :=-a.x ;if a.y <0 then a.
y :=-a.y ;if a.z <0 then a.z :=-a.z ;if a.w <0 then a.w :=-a.w ;end;function VLerp(const a,b:TV4i;const p:single):TV4i;begin result.x :=a.x +round((b.x -a.x )*p);result.y :=a.y +round((b.y -a.y )*p);result.z :=a.z +round((b.z -a.z )*p);result.w :=a.w +round((b.w -a.w )*p);end;function VMin(const a,b:TV4i):TV4i;begin if b.x <a.x then result.x :=b.x else result.x :=a.x ;if b.y <a.y then result.y :=b.y else result.y :=a.y ;if b.z <a.z then result.z :=b.z else result.z :=a.z ;if b.w <a.w then result.w :=b.w else result.w :=a.w ;end;procedure PVMin(var a:TV4i;const b:TV4i);begin if b.x <a.x then a.x :=b.x ;if b.y <a.y then a.y :=b.y ;if b.z <a.z then a.z :=b.z ;if b.w <a.w then a.w :=b.w ;end;function VMax(const a,b:TV4i):TV4i;begin if b.x >a.x then result.x :=b.x else result.x :=a.x ;if b.y >a.y then result.y :=b.y else result.y :=a.y ;if b
.z >a.z then result.z :=b.z else result.z :=a.z ;if b.w >a.w then result.w :=b.w else result.w :=a.w ;end;procedure PVMax(var a:TV4i;const b:TV4i);begin if b.x >a.x then a.x :=b.x ;if b.y >a.y then a.y :=b.y ;if b.z >a.z then a.z :=b.z ;if b.w >a.w then a.w :=b.w ;end;function VDot(const a,b:TV4i):integer;begin result:=a.x *b.x +a.y *b.y +a.z *b.z +a.w *b.w ;end;function VCrossZ(const a,b:TV4i):integer;begin result:=a.x *b.y -a.y *b.x end;

function VLengthSqr(const a:TV2f):single;begin result:=a.x *a.x +a.y *a.y ;end;function VLengthManh(const a:TV2f):single;begin result:=abs(a.x )+abs(a.y );end;function VLength(const a:TV2f):single;begin result:=(sqrt(a.x *a.x +a.y *a.y ));end;function VDistSqr(const a,b:TV2f):single;begin result:=sqr(a.x -b.x )+sqr(a.y -b.y );end;function VDistManh(const a,b:TV2f):single;begin result:=abs(a.x -b.x )+abs(a.y -b.y );end;function VDist(const a,b:TV2f):single;begin result:=(sqrt(sqr(a.x -b.x )+sqr(a.y -b.y )));end;function VAbs(const a:TV2f):TV2f;begin result.x :=abs(a.x );result.y :=abs(a.y );end;procedure PVAbs(var a:TV2f);begin if a.x <0 then a.x :=-a.x ;if a.y <0 then a.y :=-a.y ;end;function VLerp(const a,b:TV2f;const p:single):TV2f;begin result.x :=a.x +((b.x -a.x )*p);result.y :=a.y +((b.y -a.y )*p);end;function VMin(const a,b:TV2f):TV2f;begin if b.x <a.x then result.x :=b.x else result.x :=a.
x ;if b.y <a.y then result.y :=b.y else result.y :=a.y ;end;procedure PVMin(var a:TV2f;const b:TV2f);begin if b.x <a.x then a.x :=b.x ;if b.y <a.y then a.y :=b.y ;end;function VMax(const a,b:TV2f):TV2f;begin if b.x >a.x then result.x :=b.x else result.x :=a.x ;if b.y >a.y then result.y :=b.y else result.y :=a.y ;end;procedure PVMax(var a:TV2f;const b:TV2f);begin if b.x >a.x then a.x :=b.x ;if b.y >a.y then a.y :=b.y ;end;function VDot(const a,b:TV2f):single;begin result:=a.x *b.x +a.y *b.y ;end;function VCrossZ(const a,b:TV2f):single;begin result:=a.x *b.y -a.y *b.x end;
function VLengthSqr(const a:TV3f):single;begin result:=a.x *a.x +a.y *a.y +a.z *a.z ;end;function VLengthManh(const a:TV3f):single;begin result:=abs(a.x )+abs(a.y )+abs(a.z );end;function VLength(const a:TV3f):single;begin result:=(sqrt(a.x *a.x +a.y *a.y +a.z *a.z ));end;function VDistSqr(const a,b:TV3f):single;begin result:=sqr(a.x -b.x )+sqr(a.y -b.y )+sqr(a.z -b.z );end;function VDistManh(const a,b:TV3f):single;begin result:=abs(a.x -b.x )+abs(a.y -b.y )+abs(a.z -b.z );end;function VDist(const a,b:TV3f):single;begin result:=(sqrt(sqr(a.x -b.x )+sqr(a.y -b.y )+sqr(a.z -b.z )));end;function VAbs(const a:TV3f):TV3f;begin result.x :=abs(a.x );result.y :=abs(a.y );result.z :=abs(a.z );end;procedure PVAbs(var a:TV3f);begin if a.x <0 then a.x :=-a.x ;if a.y <0 then a.y :=-a.y ;if a.z <0 then a.z :=-a.z ;end;function VLerp(const a,b:TV3f;const p:single):TV3f;begin result.x :=a.x +((b.x -a
.x )*p);result.y :=a.y +((b.y -a.y )*p);result.z :=a.z +((b.z -a.z )*p);end;function VMin(const a,b:TV3f):TV3f;begin if b.x <a.x then result.x :=b.x else result.x :=a.x ;if b.y <a.y then result.y :=b.y else result.y :=a.y ;if b.z <a.z then result.z :=b.z else result.z :=a.z ;end;procedure PVMin(var a:TV3f;const b:TV3f);begin if b.x <a.x then a.x :=b.x ;if b.y <a.y then a.y :=b.y ;if b.z <a.z then a.z :=b.z ;end;function VMax(const a,b:TV3f):TV3f;begin if b.x >a.x then result.x :=b.x else result.x :=a.x ;if b.y >a.y then result.y :=b.y else result.y :=a.y ;if b.z >a.z then result.z :=b.z else result.z :=a.z ;end;procedure PVMax(var a:TV3f;const b:TV3f);begin if b.x >a.x then a.x :=b.x ;if b.y >a.y then a.y :=b.y ;if b.z >a.z then a.z :=b.z ;end;function VDot(const a,b:TV3f):single;begin result:=a.x *b.x +a.y *b.y +a.z *b.z ;end;function
VCrossZ(const a,b:TV3f):single;begin result:=a.x *b.y -a.y *b.x end;
function VLengthSqr(const a:TV4f):single;begin result:=a.x *a.x +a.y *a.y +a.z *a.z +a.w *a.w ;end;function VLengthManh(const a:TV4f):single;begin result:=abs(a.x )+abs(a.y )+abs(a.z )+abs(a.w );end;function VLength(const a:TV4f):single;begin result:=(sqrt(a.x *a.x +a.y *a.y +a.z *a.z +a.w *a.w ));end;function VDistSqr(const a,b:TV4f):single;begin result:=sqr(a.x -b.x )+sqr(a.y -b.y )+sqr(a.z -b.z )+sqr(a.w -b.w );end;function VDistManh(const a,b:TV4f):single;begin result:=abs(a.x -b.x )+abs(a.y -b.y )+abs(a.z -b.z )+abs(a.w -b.w );end;function VDist(const a,b:TV4f):single;begin result:=(sqrt(sqr(a.x -b.x )+sqr(a.y -b.y )+sqr(a.z -b.z )+sqr(a.w -b.w )));end;function VAbs(const a:TV4f):TV4f;begin result.x :=abs(a.x );result.y :=abs(a.y );result.z :=abs(a.z );result.w :=abs(a.w );end;procedure PVAbs(var a:TV4f);begin if a.x <0 then a.x :=-a.x ;if a.y <0 then a.y :=-a.y ;if
a.z <0 then a.z :=-a.z ;if a.w <0 then a.w :=-a.w ;end;function VLerp(const a,b:TV4f;const p:single):TV4f;begin result.x :=a.x +((b.x -a.x )*p);result.y :=a.y +((b.y -a.y )*p);result.z :=a.z +((b.z -a.z )*p);result.w :=a.w +((b.w -a.w )*p);end;function VMin(const a,b:TV4f):TV4f;begin if b.x <a.x then result.x :=b.x else result.x :=a.x ;if b.y <a.y then result.y :=b.y else result.y :=a.y ;if b.z <a.z then result.z :=b.z else result.z :=a.z ;if b.w <a.w then result.w :=b.w else result.w :=a.w ;end;procedure PVMin(var a:TV4f;const b:TV4f);begin if b.x <a.x then a.x :=b.x ;if b.y <a.y then a.y :=b.y ;if b.z <a.z then a.z :=b.z ;if b.w <a.w then a.w :=b.w ;end;function VMax(const a,b:TV4f):TV4f;begin if b.x >a.x then result.x :=b.x else result.x :=a.x ;if b.y >a.y then result.y :=b.y else result.y :=a.y ;if b.z >a.z then result.z :=b.z
else result.z :=a.z ;if b.w >a.w then result.w :=b.w else result.w :=a.w ;end;procedure PVMax(var a:TV4f;const b:TV4f);begin if b.x >a.x then a.x :=b.x ;if b.y >a.y then a.y :=b.y ;if b.z >a.z then a.z :=b.z ;if b.w >a.w then a.w :=b.w ;end;function VDot(const a,b:TV4f):single;begin result:=a.x *b.x +a.y *b.y +a.z *b.z +a.w *b.w ;end;function VCrossZ(const a,b:TV4f):single;begin result:=a.x *b.y -a.y *b.x end;

function VLengthSqr(const a:TV2d):double;begin result:=a.x *a.x +a.y *a.y ;end;function VLengthManh(const a:TV2d):double;begin result:=abs(a.x )+abs(a.y );end;function VLength(const a:TV2d):double;begin result:=(sqrt(a.x *a.x +a.y *a.y ));end;function VDistSqr(const a,b:TV2d):double;begin result:=sqr(a.x -b.x )+sqr(a.y -b.y );end;function VDistManh(const a,b:TV2d):double;begin result:=abs(a.x -b.x )+abs(a.y -b.y );end;function VDist(const a,b:TV2d):double;begin result:=(sqrt(sqr(a.x -b.x )+sqr(a.y -b.y )));end;function VAbs(const a:TV2d):TV2d;begin result.x :=abs(a.x );result.y :=abs(a.y );end;procedure PVAbs(var a:TV2d);begin if a.x <0 then a.x :=-a.x ;if a.y <0 then a.y :=-a.y ;end;function VLerp(const a,b:TV2d;const p:single):TV2d;begin result.x :=a.x +((b.x -a.x )*p);result.y :=a.y +((b.y -a.y )*p);end;function VMin(const a,b:TV2d):TV2d;begin if b.x <a.x then result.x :=b.x else result.x :=a.
x ;if b.y <a.y then result.y :=b.y else result.y :=a.y ;end;procedure PVMin(var a:TV2d;const b:TV2d);begin if b.x <a.x then a.x :=b.x ;if b.y <a.y then a.y :=b.y ;end;function VMax(const a,b:TV2d):TV2d;begin if b.x >a.x then result.x :=b.x else result.x :=a.x ;if b.y >a.y then result.y :=b.y else result.y :=a.y ;end;procedure PVMax(var a:TV2d;const b:TV2d);begin if b.x >a.x then a.x :=b.x ;if b.y >a.y then a.y :=b.y ;end;function VDot(const a,b:TV2d):double;begin result:=a.x *b.x +a.y *b.y ;end;function VCrossZ(const a,b:TV2d):double;begin result:=a.x *b.y -a.y *b.x end;
function VLengthSqr(const a:TV3d):double;begin result:=a.x *a.x +a.y *a.y +a.z *a.z ;end;function VLengthManh(const a:TV3d):double;begin result:=abs(a.x )+abs(a.y )+abs(a.z );end;function VLength(const a:TV3d):double;begin result:=(sqrt(a.x *a.x +a.y *a.y +a.z *a.z ));end;function VDistSqr(const a,b:TV3d):double;begin result:=sqr(a.x -b.x )+sqr(a.y -b.y )+sqr(a.z -b.z );end;function VDistManh(const a,b:TV3d):double;begin result:=abs(a.x -b.x )+abs(a.y -b.y )+abs(a.z -b.z );end;function VDist(const a,b:TV3d):double;begin result:=(sqrt(sqr(a.x -b.x )+sqr(a.y -b.y )+sqr(a.z -b.z )));end;function VAbs(const a:TV3d):TV3d;begin result.x :=abs(a.x );result.y :=abs(a.y );result.z :=abs(a.z );end;procedure PVAbs(var a:TV3d);begin if a.x <0 then a.x :=-a.x ;if a.y <0 then a.y :=-a.y ;if a.z <0 then a.z :=-a.z ;end;function VLerp(const a,b:TV3d;const p:single):TV3d;begin result.x :=a.x +((b.x -a
.x )*p);result.y :=a.y +((b.y -a.y )*p);result.z :=a.z +((b.z -a.z )*p);end;function VMin(const a,b:TV3d):TV3d;begin if b.x <a.x then result.x :=b.x else result.x :=a.x ;if b.y <a.y then result.y :=b.y else result.y :=a.y ;if b.z <a.z then result.z :=b.z else result.z :=a.z ;end;procedure PVMin(var a:TV3d;const b:TV3d);begin if b.x <a.x then a.x :=b.x ;if b.y <a.y then a.y :=b.y ;if b.z <a.z then a.z :=b.z ;end;function VMax(const a,b:TV3d):TV3d;begin if b.x >a.x then result.x :=b.x else result.x :=a.x ;if b.y >a.y then result.y :=b.y else result.y :=a.y ;if b.z >a.z then result.z :=b.z else result.z :=a.z ;end;procedure PVMax(var a:TV3d;const b:TV3d);begin if b.x >a.x then a.x :=b.x ;if b.y >a.y then a.y :=b.y ;if b.z >a.z then a.z :=b.z ;end;function VDot(const a,b:TV3d):double;begin result:=a.x *b.x +a.y *b.y +a.z *b.z ;end;function
VCrossZ(const a,b:TV3d):double;begin result:=a.x *b.y -a.y *b.x end;
function VLengthSqr(const a:TV4d):double;begin result:=a.x *a.x +a.y *a.y +a.z *a.z +a.w *a.w ;end;function VLengthManh(const a:TV4d):double;begin result:=abs(a.x )+abs(a.y )+abs(a.z )+abs(a.w );end;function VLength(const a:TV4d):double;begin result:=(sqrt(a.x *a.x +a.y *a.y +a.z *a.z +a.w *a.w ));end;function VDistSqr(const a,b:TV4d):double;begin result:=sqr(a.x -b.x )+sqr(a.y -b.y )+sqr(a.z -b.z )+sqr(a.w -b.w );end;function VDistManh(const a,b:TV4d):double;begin result:=abs(a.x -b.x )+abs(a.y -b.y )+abs(a.z -b.z )+abs(a.w -b.w );end;function VDist(const a,b:TV4d):double;begin result:=(sqrt(sqr(a.x -b.x )+sqr(a.y -b.y )+sqr(a.z -b.z )+sqr(a.w -b.w )));end;function VAbs(const a:TV4d):TV4d;begin result.x :=abs(a.x );result.y :=abs(a.y );result.z :=abs(a.z );result.w :=abs(a.w );end;procedure PVAbs(var a:TV4d);begin if a.x <0 then a.x :=-a.x ;if a.y <0 then a.y :=-a.y ;if
a.z <0 then a.z :=-a.z ;if a.w <0 then a.w :=-a.w ;end;function VLerp(const a,b:TV4d;const p:single):TV4d;begin result.x :=a.x +((b.x -a.x )*p);result.y :=a.y +((b.y -a.y )*p);result.z :=a.z +((b.z -a.z )*p);result.w :=a.w +((b.w -a.w )*p);end;function VMin(const a,b:TV4d):TV4d;begin if b.x <a.x then result.x :=b.x else result.x :=a.x ;if b.y <a.y then result.y :=b.y else result.y :=a.y ;if b.z <a.z then result.z :=b.z else result.z :=a.z ;if b.w <a.w then result.w :=b.w else result.w :=a.w ;end;procedure PVMin(var a:TV4d;const b:TV4d);begin if b.x <a.x then a.x :=b.x ;if b.y <a.y then a.y :=b.y ;if b.z <a.z then a.z :=b.z ;if b.w <a.w then a.w :=b.w ;end;function VMax(const a,b:TV4d):TV4d;begin if b.x >a.x then result.x :=b.x else result.x :=a.x ;if b.y >a.y then result.y :=b.y else result.y :=a.y ;if b.z >a.z then result.z :=b.z
else result.z :=a.z ;if b.w >a.w then result.w :=b.w else result.w :=a.w ;end;procedure PVMax(var a:TV4d;const b:TV4d);begin if b.x >a.x then a.x :=b.x ;if b.y >a.y then a.y :=b.y ;if b.z >a.z then a.z :=b.z ;if b.w >a.w then a.w :=b.w ;end;function VDot(const a,b:TV4d):double;begin result:=a.x *b.x +a.y *b.y +a.z *b.z +a.w *b.w ;end;function VCrossZ(const a,b:TV4d):double;begin result:=a.x *b.y -a.y *b.x end;

{ define FloatFunctBody(nt,typ)
function VNormalize(const a:TV##nt):TV##nt;begin result:=a*(1/VLength(a))end;
procedure PVNormalize(var a:TV##nt);begin a:=a*(1/VLength(a))end}

function VNormalize(const a:TV2f):TV2f;begin result:=a*(1/VLength(a))end;procedure PVNormalize(var a:TV2f);begin a:=a*(1/VLength(a))end;
function VNormalize(const a:TV3f):TV3f;begin result:=a*(1/VLength(a))end;procedure PVNormalize(var a:TV3f);begin a:=a*(1/VLength(a))end;
function VNormalize(const a:TV4f):TV4f;begin result:=a*(1/VLength(a))end;procedure PVNormalize(var a:TV4f);begin a:=a*(1/VLength(a))end;

function VNormalize(const a:TV2d):TV2d;begin result:=a*(1/VLength(a))end;procedure PVNormalize(var a:TV2d);begin a:=a*(1/VLength(a))end;
function VNormalize(const a:TV3d):TV3d;begin result:=a*(1/VLength(a))end;procedure PVNormalize(var a:TV3d);begin a:=a*(1/VLength(a))end;
function VNormalize(const a:TV4d):TV4d;begin result:=a*(1/VLength(a))end;procedure PVNormalize(var a:TV4d);begin a:=a*(1/VLength(a))end;

{ define VCrossBody(nt)
function VCross(const a,b:TV##nt):TV##nt;begin
  Result.x :=a.y *b.z -a.z *b.y ;
  Result.y :=a.z *b.x -a.x *b.z ;
  Result.z :=a.x *b.y -a.y *b.x ;}
{ define VCrossBody3(t) VCrossBody(3##t)end}
{ define VCrossBody4(t) VCrossBody(4##t)result.w :=0;end}
function VCross(const a,b:TV3i):TV3i;begin Result.x :=a.y *b.z -a.z *b.y ;Result.y :=a.z *b.x -a.x *b.z ;Result.z :=a.x *b.y -a.y *b.x ;end;
function VCross(const a,b:TV4i):TV4i;begin Result.x :=a.y *b.z -a.z *b.y ;Result.y :=a.z *b.x -a.x *b.z ;Result.z :=a.x *b.y -a.y *b.x ;result.w :=0;end;
function VCross(const a,b:TV3f):TV3f;begin Result.x :=a.y *b.z -a.z *b.y ;Result.y :=a.z *b.x -a.x *b.z ;Result.z :=a.x *b.y -a.y *b.x ;end;
function VCross(const a,b:TV4f):TV4f;begin Result.x :=a.y *b.z -a.z *b.y ;Result.y :=a.z *b.x -a.x *b.z ;Result.z :=a.x *b.y -a.y *b.x ;result.w :=0;end;
function VCross(const a,b:TV3d):TV3d;begin Result.x :=a.y *b.z -a.z *b.y ;Result.y :=a.z *b.x -a.x *b.z ;Result.z :=a.x *b.y -a.y *b.x ;end;
function VCross(const a,b:TV4d):TV4d;begin Result.x :=a.y *b.z -a.z *b.y ;Result.y :=a.z *b.x -a.x *b.z ;Result.z :=a.x *b.y -a.y *b.x ;result.w :=0;end;

end.

